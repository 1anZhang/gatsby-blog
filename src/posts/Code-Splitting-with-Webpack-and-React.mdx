---
title: 使用Webpack和React进行代码分割(译)
date: 2018-11-12 17:00:03
tags:
---

# 使用Webpack和React进行代码分割(译)

毫无疑问网页性能是一件很重要的事情。我们的应用应该更快的加载，以此来保持用户的注意力并提高他们的体验。

开发时，我们通常会使用高于平均水平的机器链接信号较好的网络，然而，不是所有的用户都有性能良好的设备和良好的信号。

我们的目标是不要让用户意识到程序正在加载。即使我们不能立即提供所有的功能，我们需要提供一些必要的反馈来保持吸引用户。为了确定程序的性能，我们需要测试最差的环境而不是最好的。

###  JS的性能消耗

关于性能有两个比较重要的点是我们需要考虑的。第一个是发送代码到用户浏览器。文件越小，用户就能越快地接收他们。

第二个是用户浏览器需要花多久来执行整个JS代码。我们有必要尽可能的保证发送的所有代码都是有用的，被执行到的，保证没有无用代码执行来拖慢时间。

### 懒加载

当我们谈论性能时，我们需要了解懒加载的两个概念。

第一个——不要浪费资源在我们不需要的地方。意思是说，我们不要浪费时间和内存在对产品用户体验没有任何好处的地方上。

第二个概念是有一件事如果我们可以之后再做，那么我们现在就不要做。意思是如果我们可以推迟发送资源，那我们总应该这样做。

这篇文章是基于React和Webpack的，但是他们同样可以用于其他类似框架上。

### **代码分割**

通过代码分割，我们可以优化代码加载速度以及利用懒加载。

当我刚开始作为一个web开发者时，最好的方法还是把所有代码压缩在一个文件中。但是随着应用的发展，我们的代码量急剧的增加。

我们需要发送越来越多的代码给用户并且发送一个包含整个应用的巨大的包给用户会严重影响到用户体验。

我们想要做的是只给用户发送他们需要的代码，当他打开一个页面时，他只需要这个页面的代码，而不是整个应用的代码。

即使用户只需要一小部分代码，传统方法我们会发送一个巨大的js包，浏览器会执行整个文件。

使用更小的包，我们可以提高用户的体验并且不会让他们产生关闭页面的想法，当用户开始关注页面时，我们可以再后台继续加载。

### **无用代码**

你可以看到大量无用代码，打开Chrome Dev Tool,按下 `Cmd + Shift + P` 并输入 `coverage`。点击刷新，就可以看到如下的内容。

![img](https://cdn-images-1.medium.com/max/1600/1*fFTQpub5xHm3Jtzm3-Oyjg.png)

它显示了我们所有的文件的加载和使用，即使没有被使用，它依旧会被解析，消耗很多的时间。

### **动态导入**

我们要通过动态导入的方式来告知Webpack哪些是我们希望分割为单独的文件。 `import` 关键字可以作为一个函数来使用，它接收模块的路径作为参数，并且返回一个Promise。



![img](https://cdn-images-1.medium.com/max/1600/1*CyrxUDs3k0WVtDgJSttPCA.png)

当模块加载完成，我们就可以接收到Promise中的resolves。注意：如果你的模块有默认导出，你需要从模块中取`default` 属性来获取到它。

在React环境中，我们想要进行代码分割的模块通常是不同的组件。所以，我们可以使用**React Loadable**。它是以高阶组件的方式进行动态导入。

![img](https://cdn-images-1.medium.com/max/1600/1*fnHQXJy2jpv06CH8LF91Dw.png)

值得注意的是，像 **React Loadable** 或 **Loadable Components** 这种库，他们以高阶组件的形式实现动态导入只是为了更加的优雅，在这背后实际上得工作还是**Webpack**来完成的。

也许，在 **React 17** 生态系统中会带来一些新的特性来让我们不需要使用这种包裹组件就能实现我们的需求。

### 路由级代码分割

最常用的代码分割范式就是以路由来进行划分。每个最顶层路由都会被分割成一个独立文件。

![img](https://cdn-images-1.medium.com/max/1600/1*HegVgTy-dBz1g3fHTSBZnA.png)

到目前为止，我们可以让用户只加载当前页面所需要的资源。

然而现在我们有一个很棒的方式去把代码分割成更小的块，通常分割成单独的库或组件才能达到最好的性能。

一个文档生成库可能会很大。我曾经见过大约 **2mb** 的库。所以即使我们按照路由进行分割，当用户访问页面时，浏览器还是需要处理很大的代码量。

现在有一种方式能优雅的解决这个问题。我们接下来将要了解如何在浏览器空闲时后台加载这些信息。

### **动态导入路由**

由于`import`可以作为一个函数，那么我们自然能想到可以传递变量作为参数，所以我们可以再运行时动态加载不同的模块。

虽然这一想法是可行的，但是也有一些问题。所有的模块必须在打包时创建，所以Webpack在遇到import中的变量时需要进行一些处理。



![img](https://cdn-images-1.medium.com/max/1600/1*zxWCYlHs8c1-5FteWAbb6w.png)

在任何时候我们像上面这样写代码，Webpack将会给 `themes` 文件夹下的所有文件创建一个模块。所以，无论我们想要导入哪个模块，都有一个已经打包好的模块可以使用。

### **给模块命名**

Webpack会给每个打包后的模块一个id，所以当你获取动态加载的模块时，你会发现文件名类似于`1.bundle.js`。我们可以使用Webpack’s **magic comments** 并且在配置中做一些小的修改，就可以给不同的模块文件命名一些有意义的名字。



![img](https://cdn-images-1.medium.com/max/1600/1*RvrMv1VtPnrCreK9I2CIow.png)

老实说，我不是magic comments的粉丝，但是这是处理命名最聪明的方式。你可以在**React Loadable**中使用magic comments，但是还是在 `import` 中使用比较清晰。

![img](https://cdn-images-1.medium.com/max/1600/1*-91-SUdXwrndthev_nYQGg.png)

在Webpack配置中添加这一行，你就可以使用你定义的名字和chunkhash作为文件名。

### **预加载和预请求**

预加载和预请求是两种我们可以用来继续提高性能的方式。

在了解技术细节、实现和一些其他的概念之前，我们有必要了解我们为什么需要它。

在之前我们讨论了在使用比较庞大的库时进行组件级别的代码分割的必要性，然而，当用户点击按钮后加载模块依旧不是一个理想的方法，因为这将会导致空白内容，或者在UI重新渲染前有一段等待时间。

当我们认为用户一定会需要某个特别的文件时，我们可以在明确需求它之前对它进行预加载或者预请求，这一需求同时是由Webpack magic comment实现的。

![img](https://cdn-images-1.medium.com/max/1600/1*ibzic8EP8LyJUXgA5J4Xuw.png)

这两种方式有什么区别呢，该如何选择他呢？预加载和预请求都会在明确引入之前请求获取，但是他们在不同层面上。

**预加载**文件将会比他的父级文件有更高的优先级，我们只有在你确保这个用户一定会很快用到它的时候才会给一个文件标记为预加载。我们可能会在下拉菜单或者相邻tab中用到它。

**预请求**文件的优先级比较低，并且只会在浏览器闲时加载。也就是说，如果一个文件用户有可能会用到，可以给他标记为预请求。比如，可以请求用户可能会跳转的下个页面。它可能并不会很快用到，但是如果用户点击时希望已经请求了。

**React Loadable**给组件提供了静态方法 `preload`，在你想要获取组件文件时候它给了你手动控制的方法。在懒加载时这个方法非常有用。我们可以等到用户一定会用到它的时候对他进行预加载。

![img](https://cdn-images-1.medium.com/max/1600/1*N0R3k8Ky-fdalFuu_9RfRA.png)

### Magic Comments的更多细节

Webpack配置加载文件的方式是通过**magic comments**实现的。说实话，我们并不需要自己去配置太多东西，但是最好知道我们并不知能做这些，知道当我们需要时我们还有更多的选择。

 `webpackMode`注释用来告诉Webpack如何解析这个文件。默认所有文件都是`lazy`模式。也就是说，每个模块都会被分割为单独的文件。

其他的选项有`lazy-once`, `eager` 和 `weak`.总之，我并不是必须要用这些，所以我并不会写它。大部分情况下使用 `lazy` 模式就可以了。关于更多细节可以查看 [Webpack文档](https://webpack.js.org/api/module-methods/#import-).

![img](https://cdn-images-1.medium.com/max/1600/1*bAdqgsyGEcONUwKaTXBCZA.png)

大部分时候你想自己定义文件名并且使用预加载或者与请求。庆幸我们可以通过逗号分隔添加多个选项。

![img](https://cdn-images-1.medium.com/max/1600/1*h5BxZZvXE7fJDVtY58Jtlw.png)

### Analyze

当我们能够去衡量性能的时候，我们才能真正讨论性能的问题。为了了解哪里可以去提高，我们需要深入了解它。在代码分割时，我们需要了解到每个文件到底有多大，文件里到底都包含一些什么。

 [**Webpack Bundle Analyzer**](https://github.com/webpack-contrib/webpack-bundle-analyzer) 是一个很棒的工具。他是一个可视化工具让我们可以看到应用中各种文件的大小占比。

![img](https://cdn-images-1.medium.com/max/1600/1*dusVhPiL44VDoS4gJHMWSg.gif)

你可以看到每个文件具体占比和大小。我们可以了解到哪些是不需要的冗余代码。比如，你发现整个 **lodash** 库都被引入了，它非常大，这时候你可以考虑只引入你所需要的哪些代码。

### 考虑未来和HTTP/2

关于提高性能，我认为代码分割是会给你带来很多好处的一项技术。

值得考虑的是，到目前为止的最佳实践依旧是把所有内容打包到一个文件内。然而，我认为如果你的团队想跟上技术潮流，代码分割是一个不错的东西。

通过 **HTTP/2** ，一次发送多个文件也不是一件难事了。把所有内容打包成一个文件的主要原因就是避免发送多个请求。通过使用**HTTP/2 Push**，我们将可以一次发送多个文件而不需要额外请求头。

### **TL;DR（对于长文章的简要总结）**

- 确保我们的应用能够在最坏的条件下有一定的性能。
- 懒加载对于性能提高有很多好处。
- 代码分割只需要花很少的时间就能获得很多的好处。当项目开始变得臃肿时引入代码分割将会使项目变得更加可扩展。
- 当我们确保用户一定会需要某些代码时，可以利用预加载和预请求提高用户体验。
- 分析你的包，尽可能去除无用的代码，移除不需要的库。
- 未来将会证明代码分割是十分有必要的。