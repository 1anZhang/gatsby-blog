---
title: Secrets of the JavaScript Ninja学习笔记(3)
date: 2017-11-19 17:05:07
tags: JavaScript, Object
---

> 记录书中重要的，有趣的，自己掌握的不太好的。

### 1 历久弥新的事件

#### 1.1 深入事件循环

事件循环不仅仅包含事件队列，而且具有至少两个队列，除了事件，还要保持浏览器执行的其他操作。这些操作被称为任务，并且分为两类：宏任务（通常称为任务）和微任务。

**宏任务**的例子很多，包括创建主文档对象、解析HTML、执行主线JavaScript代码，更改当前URL以及各种事件，如页面加载、输入、网络事件和定时器事件。从浏览器角度来看，宏任务代表一个个离散的、独立工作单元。

**微任务**是更小的任务。微任务更新应用程序的状态，但必须在浏览器任务继续执行其他任务之前执行，微任务包括promise回调函数，DOM发生变化等。微任务需要尽可能快地、通过异步方式执行，同时不能产生全新的微任务。微任务使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的重绘，UI重绘会使应用程序的状态不连续。

**事件循环**：在一次迭代中，事件循环将首先检查宏任务队列，如果宏任务等待，则立即开始执行宏任务，直到该任务运行完成，事件循环将移动去处理微任务队列。如果有任务在改队列中等待，则事件循环将依次开始执行，完成一个后执行余下的微任务，直到所有微任务执行完毕。

**宏任务队列**和**微任务队列**的区别：单次循环迭代中，最多处理一个宏任务，而队列中的所有的微任务都会被处理。

微任务队列处理完毕并清空时，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI视图。

##### 1.1.1 仅含宏任务的示例

```html
<button id="firstButton"></button>
<button id="secondButton"></button>
<script>
	const firstButton = document.getElementById("firstButton");
  const secondButton = document.getElementById("secondButton");
  firstButton.addEventListener("click" function firstHandler() {
    // 假设这里执行需要8ms
  });
  secondButton.addEventListener("click", function secondHandler() {
    // 假设这里执行也需要5ms
  })
  // 假设这里有一堆代码需要执行15ms
</script>
```

首先我们做出一些假设：

- 主线程JavaScript代码的执行时间需要15ms
- 第一个单击事件处理器需要运行8ms
- 第二个单击事件处理器需要运行5ms

现在，如果有一个用户在代码执行后5ms的时候单击了第一个按钮，随后在第12ms单击了第二个按钮。

1. 由于JavaScript基于单线程执行模型，单击按钮并不会立即执行对应的处理器。而是进入任务队列，等待执行。事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。
2. 在15ms时，主线程JavaScript代码执行完成。事件循环转向微任务，由于不存在微任务，直接跳转到更新UI，UI发生变化会消耗一些时间，我们暂时忽略。
3. 接着firstButton单击任务开始执行，执行8ms且不被中断，到23ms时，任务执行完成，浏览器又一次检查微任务，微任务队列仍为空，根据需要是否渲染页面。
4. 最后，在第三次循环迭代中，secondButton单击事件开始执行，5ms后执行完成，任务队列为空。三次事件循环结束。

##### 1.1.2 同时含有宏任务和微任务的示例

最简单的添加微任务的方式就是加入promise，promise是一个占位符，指向一个还没有来但将来会有的值，承诺我们最终会取得异步计算的结果。

```html
<button id="firstButton"></button>
<button id="secondButton"></button>
<script>
	const firstButton = document.getElementById("firstButton");
  const secondButton = document.getElementById("secondButton");
  firstButton.addEventListener("click" function firstHandler() {
    Promise.resolve().then(() => {
      // 假设这里需要执行4ms
    })
  });
  secondButton.addEventListener("click", function secondHandler() {
    // 假设这里执行也需要5ms
  })
  // 假设这里有一堆代码需要执行15ms
</script>
```

这个示例与之前唯一的区别是给第一个点击事件添加了promise，此时事件循环与之前不同的点在于，第一个点击事件完成后，会检查微任务队列，此时发现了Promise函数，此时会执行4ms，也就是在27ms的时候第二个点击事件才会执行。

#### 1.2 玩转计时器

与事件循环不同，setTimeout和setInterval是由宿主环境（浏览器或node.js）定义的。

```html
<button id="myButton"></button>
<script>
  setTimeout(function timeoutHandler(){
    // 假设这里执行6ms
  }, 10);
  setInterval(function intervalHandler() {
    // 假设这里执行8ms
  }, 10)
  
  const myButton = document.getElementById("myButton")
  myButton.addEventListener("click", function clickHandler() {
    // 假设这里执行10ms
  })
  // 假设主线程还要执行18ms
</script>
```

这里注册了两个计时器和一个按钮点击事件，假设某个用户在执行到6ms的时候点击了这个按钮。

1. 在0ms时，两个计时器触发，添加到队列中。
2. 在6ms时，单击鼠标。
3. 在10ms时，两个计时器时间到。
4. 在18ms时，主线程代码执行结束，一次循环事件结束，触发点击事件处理程序，运行10ms，一次循环事件结束。
5. 在28ms时，timeout计时器触发，执行6ms，一次循环事件结束。
6. 在34ms时，触发interval计时器，执行8ms，一次循环事件结束。
7. 在42ms时，第一次interval计时器结束，此时在40ms又添加了新的interval计时器，此时继续运行，一次循环事件结束。
8. 在50ms时，又一次interval事件开始，此后进入正常的每10ms执行一次。

由于每次事件循环只会执行一个宏任务，interval的事件，在前30秒都没有得到执行，那么每隔10ms时，都不会添加新的间隔计时器，因为队列中有一个与之相匹配的间隔计时器，我们期望间隔计时器能够在10、20、30、40、50、60、70执行，但是最终结果是34、42、50、60、70。

这就说明在单线程执行过程中，计时器只能保证添加到队列的时间，但是不能保证执行时间。

##### 1.2.1 处理计算复杂度高的任务

```html
<table>
  <tbody></tbody>
</table>
<script>
  // 非常费时的dom操作，可能阻塞整个应用
	const tbody = document.querySelector("tbody")
  for (let i = 0; i < 20000; i++) {
    const tr = document.createElement("tr")
    for (let t = 0; t < 6; t++) {
      const td = document.createElement("td")
      td.appenChild(document.createTextNode(i + "," + t))
    }
    tbody.appendChild(tr)
  }
</script>
```

此时，我们要做的就是使用定时器来定期终止这个阻塞进程，来让其他代码能够执行。

```js
const rowCount = 20000
const divideInfo = 4
const chunkSize = rowCount / divideInfo;
let iteration = 0
const table = document.getElementsByTagName("tbody")[0]

setTimeout(function generateRows() {
  const base = chunkSize * iteration
  for (let i = 0; i < chunkSize; i++) {
    const tr = document.createElement("tr")
    for (let t = 0; t < 6; t++) {
      const td = document.createElement("td")
      td.appenChild(document.createTextNode((i + base) + "," + t + "," + iteration))
      tr.appendChild(td)
    }
    table.appendChild(tr)
  }
  iteration++
  if (iteration < divideInfo) {
    setTimeout(generateRows, 0)
  }
}, 0)
```

之前，我们一次创建24万个节点，之间不能停止，页面不会渲染，别的代码不能执行，整个程序阻塞在这里。

之后，我们通过异步的方式，将之前的代码分割为了4个片段，在每个代码执行后，事件循环都会结束，页面都可以重新渲染，如果有别的任务，也能够执行。我们可以设置divideInfo来将长片段分割成跟多的片段。通过定时器操作，我们可以给用户提供更好的用户体验。

#### 1.3 处理事件

与其他大多数函数类似，在事件处理器内部，我们可以使用this关键字。通常来说在事件处理器内部，this指向事件发生的对象，但很快我们就会发现，这并不准确。this关键字指向事件处理器所注册的元素。虽然通常注册的元素就是事件发生的元素，但是总有例外。

##### 1.3.1 事件代理

```html
<html>
  <head>
    <style>
      #outerContainer { width: 100px; height: 100px; background-color: blue; }
      #innerContainer { width: 50px; height: 50px; background-color: red; }
    </style>
  </head>
  <body>
    <div id="outerContainer">
      <div id="innerContainer"></div>
    </div>
    <script>
    	const outerContainer = document.getElementById("outerContainer")
      const innerContainer = document.getElementById("innerContainer")
      outerContainer.addEventListener("click", () => {
        report("Outer container click")
      })
      innerContainer.addEventListener("click", () => {
        report("Inner container click")
      })
      
      document.addEventListener("click", () => {
        report("Document click")
      })
    </script>
  </body>
</html>
```

浏览器的事件默认处理顺序是先捕获，再冒泡，addEventListener的第三个参数定义了事件触发阶段，true则表明在捕获阶段，false是在冒泡阶段，此时我们注册了3个事件，当点击innerContainer的时候，触发顺序为inner-->outer-->document。

```js
// 如果我们改变一个参数
outerContainer.addEventListener("click", () => {
  report("Outer container click")
}, true)
```

此时触发的顺序为outer-->inner-->document

那么我们再回到this的问题，this的指向是事件处理器注册的元素，不一定是事件发生的元素。而e.target永远指向事件发生的元素。

```js
// 给每一个表格添加单独的点击事件
const cells = document.querySelectorAll('td')
for (let n = 0; n < cells.length; n++) {
  cells[n].addEventListener('click', function() {
    this.style.backgroundColor = 'yellow'
  })
}

// 在父级创建唯一的事件处理，通过冒泡处理发生的事件。
const table = document.getElementById('someTalbe')
table.addEventListener('click', function(event) {
  if (event.target.tagName.toLowerCase() === 'td') {
    event.target.style.backgroundColor = 'yellow'
  }
})
```

##### 1.3.2 自定义事件

```js
// 假设我们自定义一个事件，当ajax开始时，页面显示一个旋转的风车，当ajax完成时，风车消失。
document.addEventListener('ajax-start', e => {
  document.getElementById('whirlyThing').style.display = 'inline-block'
})

document.addEventListener('ajax-complete', e => {
  document.getElementById('whirlyThing').style.display = 'none'
})
```

现在我们需要自定义事件来触发这个事件监听器：

```html
<style>
  #whirlyThing { display: none }
</style>
<button type="button" id="clickMe">start</button>
<img id="whirlyThing" src="whirly-thing.gif" />

<script>
  function triggerEvent(target, eventType, eventDetail) {
    // 核心就是创建一个CustomEvent对象，并且传入eventType
    const event = new CustomEvent(eventType, {
      detail: eventDetail
    })
    // 然后通过一个节点去派发这个事件
    target.dispatchEvent(event)
  }
  function performAjaxOperation() {
    triggerEvent(document, 'ajax-start', {url: 'my-url'})
    setTimeout(() => {
      triggerEvent(document, 'ajax-complete')
    }, 5000)
  }
  const button = document.getElementById('clickMe')
  button.addEventListener('click', () => {
    performAjaxOperation()
  })
</script>
```

这样，点击按钮我们就能触发一个自定义的事件，并且给document添加了事件监听器，我们就可以在页面中使用自定义的事件了。使用自定义事件可以大大降低程序的耦合性，事件的派发和监听器良好的分离。