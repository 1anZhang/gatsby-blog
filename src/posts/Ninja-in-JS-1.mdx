---
title: Secrets of the JavaScript Ninja学习笔记(1)
date: 2017-09-19 15:42:59
tags: JavaScript, Function
---

> 记录书中重要的，有趣的，自己掌握的不太好的。

### 1 函数的定义与参数

#### 1.1 函数式的不同点

在JavaScript中，我们可以用函数实现一个对象所具有的功能，包括添加属性，作为参数传入函数，并且作为返回值返回，函数是第一类对象，函数的唯一特殊之处在于它是可以调用的。

> JavaScript中的函数式编程
>
> - 把函数作为第一类对象是函数式编程的第一步，函数式编程是一种编程风格，它通过书写函数式(而不是指定一系列执行步骤，就想那种更主流的命令式编程)代码来解决问题。函数式编程可以让代码更容易测试、扩展及模块化。

第一类对象的特点之一就是它能够作为参数传入函数，我们最常用的方式就是回调函数。这种方式的好处是，可以在函数内部传入参数给回调函数，可以让决定回调函数的执行时间。

比如下面这个简单的排序函数。

```js
var values = [0, 3, 2, 4, 7, 9]

values.sort(function(value, value2) {
  return value - value2
})
```

函数式的方式让我们能把函数作为一个单独的实体来创建，正像我们对待其他类型一样，创建它、作为参数传入另一个方法并将它作为一个参数来接收。函数就这样显示了它一等公民的地位。

#### 1.2 函数作为对象的乐趣

##### 1.2.1 存储函数

假设我们需要管理某个函数发生后需要调用的回调函数集合，我们会存储元素唯一的集合，当我们像这样的集合中添加函数时，会面临两个问题，哪个函数对于这个集合来说是一个新函数，从而被加入集合中？又是哪个函数已经存在于集合中，从而不需要再次加入到集合中？

简单的遍历自然很容易实现，但是这样的实现方式新能不好，并且也很不ninja，所以，

```js
var store = {
  nextId: 1,
  cache: {},
  add: function (fn) {
    //当函数中不存在id属性时，它是一个新加入的函数，并且给他添加唯一的id
    if (!fn.id) {
      fn.id = this.nextId++
      this.cache[fn.id] = fn
      return true
    }
  }
}
```

##### 1.2.2 自记忆函数

记忆化(memorization)是一种构建函数的处理过程，能够记住上次计算结果。这样，当传入的参数相同时，我们可以直接返回上次的计算结果而不是重新计算。对于动画中的计算，搜索中不经常变化的数据或任何消耗时间的数学计算来说，记忆化都是十分有用的。

比如判断一个数是否是质数，

```js
function isPrime(value) {
  if (!isPrime.answers) {
    isPrime.answers = {}
  }
  if (isPrime.answers[value] !== undefined) {
    return isPrime.answers[value]
  }
  // 0和1肯定不是质数
  var prime = value !== 0 && value !== 1
  for (var i = 2; i < value; i++) {
    if (value % i ===0) {
      prime = false
      break
    }
  }
  return isPrime.answers[value] = prime
}
```

这个方法具有两个优点：

- 由于函数调用时会寻找之前调用所得到的值，所以性能会提高。
- 它几乎是无缝发生在后头，最终用户和页面作者都不需要关心实现即可顺利工作。

但是还是存在一些问题，需要做权衡利弊：

- 任何类型的缓存都必然会为性能牺牲内存
- 纯粹主义者会认为缓存逻辑不应该和业务逻辑混合，函数或方法只需要把一件事做好。(第八章会改进)
- 对于这类问题很难做负载测试或估算算法复杂度，因为结果依赖于函数之前的输入

#### 1.3 函数定义

JavaScript函数通常由函数字面量来创建函数值，它提供了4类定义函数的方式：

- 函数定义(function declarations)和函数表达式(function expression) ——最常用，在定义函数上有微妙不同的两种方式。

  `function myFunc(){ return 1 }`

- 箭头函数(通常被叫做lambda函数)——ES6新增的JavaScript标准，能让我们尽量简洁的语法定义函数。

  `myArg => myArg * 2`

- 函数构造函数——一种不常用的函数定义方式。能让我们以字符串形式动态构造一个函数，这样得到的函数是动态生成的。

  `New Function('a', 'b', 'return a + b')`

- 生成器函数——ES6新增功能，能让我们创建不同于普通函数的函数，在应用程序执行过程中，这种函数能够推出再重新进入，在这些再进入之间保留函数内变量的值。

  `function* myGen() { yield 1 }`

> 为什么立即调用函数表达式(IIFE)需要被括号包起来？
>
> - 原因是纯语法的层面的，JavaScript解释器必须能够轻易区分函数声明和函数表达式之前的区别。如果去掉包裹函数表达式的括号，`function(){}(3)`，JavaScript解释器在第一行就会报错，因为它会被解释器认为是一个函数声明，以function开头却没有声明名字，所以为了避免错误，就要放在括号内，让解释器识别它正在处理一个函数表达式。
> - 同样`(function(){}(3))`也能达到同样目标，然而这种方式很奇怪，故不常使用。
> - `+function(){}()`、`-function(){}()`、`!function(){}()`、`~function(){}()`这4中方式在库中也能经常见到，主要作用也是告诉解释器，这是一个函数表达式而不是函数声明。一元操作费得到的结果没有存储到任何地方，它并不重要，重要的是调用IIFE。

### 2 理解函数调用

#### 2.1 隐式函数参数

- arguments:  用来获取传递给函数的参数所有参数，类数组结构，但不具有数组的方法，能通过下标访问参数，具有length属性，在非严格模式下可以动态改变传递的参数，严格模式将不可改变。
- this: 代表函数调用相关联的对象，通常称为函数上下文，接下来将深入this。

#### 2.2 函数调用

我们可以通过4种方式调用一个函数，每种方式之间有一些细微差别。

- 作为一个函数(function)——`skulk()`，直接被调用。
- 作为一个方法(method)——`ninja.skulk()`，关联在一个对象上，实现面向对象编程。
- 作为一个构造函数(constructor)——`new Ninja()`，实例化一个新对象。
- 通过函数的apply或者call方法——`skulk.apply(ninja)`或者`skulk.call(ninja)`

```js
function skulk(name) {}
function Ninja() {} {
  this.skulk = function() {
    return this
  }
}

//作为函数调用,当在这种方式下，this的指向有两种可能性：
//在非严格模式下，它将是全局上下文(window对象)
//而在非严格模式下，它将是undefined
skulk('Hattori')
(function(who) { return who })('Hattori')

//作为ninja对象的一个方法调用,此时的this指向该对象
var ninja = {
  skulk: function() {}
}
ninja.skulk('Hattori')

//作为构造函数调用时，this指向创建的对象
var ninja = new Ninja()

//通过call或者apply调用
//当我们将某个对象的方法作为回调函数传入别的函数时，可能在这个方法被调用的时候
//它的上下文环境就已经改变了，使用下面两个函数，我们可以显式指定函数的this指向
skulk.call(ninja, 'Hattori')
skulk.apply(ninja, 'Hattori')

//实现forEach迭代方法展示如何设置函数上下文
function froEach(list, callback) {
  for (var n = 0; n < list.length; n++) {
    callback.call(list[n], n)
  }
}

var weapons = [
  { type: 'shuriken' },
  { type: 'katana' },
  { type: 'nunchucks' }
]

forEach(weapons, function(index){
  //this === weapons[index]
})
```

##### 2.2.1 关于构造函数

构造函数的目的是根据初始条件对函数调用创建的新对象进行初始化，虽然这些函数也能被正常调用，但是并没有太大的意义。

使用关键字new来构造新的对象，主要会触发以下几个动作：

1. 创建一个新的空对象。
2. 该对象作为this传入构造函数，从而成为构造函数的上下文。
3. 新构造的对象作为new运算符的返回值。

如果构造函数有返回值，那么：

- 如果构造函数返回的是一个对象，那么该对象将作为整个表达式的返回值，而传入构造函数的this将被丢弃。
- 如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象。

#### 2.3 解决函数上下文的问题

- 箭头函数的this指向定义它的上下文。在函数内定义则绑定该函数，在普通对象中定义则指向window。
- bind方法只绑定上下文但不执行。它会返回一个新创建的绑定特定上下文的函数，利用闭包。

### 3 闭包和作用域

- 闭包创建了被定义时的作用域内的变量和函数的安全气泡，因此函数获得了执行时所需的内容。该气泡和函数本身一起包含了函数和变量。使用闭包时，所有的信息都会被存储在内存中，直到JavaScript引擎确保这些信息不再被使用(可以安全地进行垃圾回收)或页面卸载时，才会清理这些信息。

- 我们可以使用闭包的高级功能：

  - 通过构造函数内的变量以及构造方法来模拟对象的私有属性。

  - 处理回调函数，简化代码

- JavaScript引擎通过执行上下文栈(调用栈)跟踪函数的执行。每次调用函数时，都会创建新的函数执行上下文，并推入调用栈顶端。当函数执行完成后，对应的执行上下文将从调用栈中推出。

- JavaScript引擎通过词法环境跟踪标识符。

- 闭包是JavaScript作用域规则的副作用。当函数创建时所在的作用域消失后，仍然能够调用函数。

```js
function Ninja() {
  var feints = 0
  this.getFeint = function() {
    return feints
  }
  this.feint = function() {
    feints++
  }
}
var ninja1 = new Ninja()
ninja1.getFeint()
// 0
ninja1.feint()
ninja1.getFeint()
// 0
ninja1.feints
// undefined 访问不到
```

函数调用栈：由于JavaScript是单线程的，所以同一时刻只能执行一个函数，那么嵌套函数实际上在调用内部函数时会把自己压入函数调用栈，然后调用内部函数，内部函数内还有函数执行则继续压入栈中。

上下文环境：函数在执行时，它的作用域就是函数内部以及函数调用栈上所有函数作用域以及全局作用域的范围。

变量的查找：查找变量是从内向外的。

#### 3.1 JavaScript的变量类型

**const**：只能在声明时被初始化一次，之后再也不允许将全新的值赋给const变量，但是，可以修改const变量已经存在的值，只是不能重写const变量。当const声明对象或数组时，只是变量的引用不可改变，对象可以添加修改属性，数组可以添加删除。

**var**：var是在距离最近的函数内部或者全局环境中定义的，var只在运行中识别函数调用栈，定义在函数中的[[environment]]的，所以不识别块级作用域。

**const和let**是在最近的词法环境中定义的，包括块级作用域，循环，以及存在的函数作用域和全局作用域。

**JavaScript执行分为两个阶段**：一旦创建了新的词法环境，就会执行第一阶段。在第一阶段，没有执行代码，但是JavaScript引擎会访问并注册当前词法环境中所声明的变量和函数。JavaScript在第一阶段完成之后开始执行第二阶段，具体如何执行取决于变量的类型和环境类型。

1. 如果是创建一个函数环境，那么创建形参及参数的默认值。如果是非函数环境，跳过此步骤。
2. 如果是创建全局或函数环境，就扫描当前代码进行函数声明(不会扫描其他函数的函数体)，但是不会执行函数表达式或箭头函数。对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若标识符已经存在，那么该标识符的值将被重写。如果是块级作用域，跳过此步骤。
3. 扫描当前代码进行变量声明。在函数或全局环境中，查找所有当前函数以及其他函数之外通过var声明的变量，并查找所有通过let或const定义的变量。在块级环境中，仅查找当前块中通过let或const定义的变量。对于查到的变量，若该标识符不存在，进行注册并将其初始化为undefined。若该标识符已经存在，将保留其值。

### 4 Generator和iterator

#### 4.1 使用generator

generator函数几乎是一个完全崭新的函数类型，它和标准的普通函数完全不同。generator函数能生成一组值的序列，但每个值的生成是基于每次请求，并不同于标准函数那样立即生成。我们必须显式地向生成器请求一个新的值，随后生成器要么响应一个新生成的值，要么就告诉我们它之后都不会再生成新值。更让人好奇的是，每当生成器函数生成了一个值，他都不会像普通函数一样停止执行。相反，生成器几乎从不挂起。随后，当对另一个值的请求到来后，生成器就会从上次离开的位置恢复执行。

```js
function* WeaponGenerator() {
  yield "Katana"
  yield "Wakizashi"
}
for (let weapon of WeaponGenerator()) {
  consolo.log(weapon)
}
// Katana Wakizashi

// generator的迭代器iterator
const weaponIterator = WeaponGenerator()
const result1 = weaponIterator.next()
// Katana
const result2 = weaponIterator.next()
// Wakizashi
const result3 = weaponIterator.next()
// undefined result3.done === true

// 使用iterator进行遍历
let item
while(!(item = weaponIterator.next()).done) {
  //item
}

// 把执行权交给下一个生成器
function* WarriorGenerator() {
  yield "Sun Tzu"
  yield* NinjaGenerator()
  yield "Genghis khan"
}

function* NinjaGenerator() {
  yield "Hattori"
  yield "Yoshi"
}

for (let warrior of WarriorGenerator()) {
  // Sun Tzu, Hattori, Yoshi, Genghis khan
}

// 用生成器生成ID序列, 此处使用next()方法不会陷入死循环，因为每调用一次next()
// 只会yield一次
function* IdGenerator() {
  let id = 0
  while (true) {
    yield ++id
  }
}
const idIterator = IdGenerator()
const ninja1 = { id: idIterator.next().value }
// 1

// 普通方法遍历DOM树
function traverseDOM(element, callback) {
  callback(element)
  element = element.firstElementChild
  while (element) {
    traverseDOM(element, callback)
    element = element.nextElementSibling
  }
}

// Generator方法遍历DOM树
function* DomTraversal(element) {
  yield element
  element = element.firstElementChild
  while (element) {
    yield* DomTraversal(element)
    element = element.nextElementSibling
  }
}
```

#### 4.2 与生成器交互

```js
function* NinjaGenerator(action) {
  const imposter = yield ("Hattori" + action)
  
  yield ("Yoshi (" + imposter + ") " + action)
}

const ninjaIterator = NinjaGenerator("skulk")

const result1 = ninjaIterator.next()
// result1.value === "Hattori skulk"

const result2 = ninjaIterator.next("Hanzo")
// result2 === "Yoshi (Hanzo) skulk"


```

第一次调用next方法，会遇到第一个yield并返回"Hattori skulk"这个值，当再次调用next方法，并且传给他"Hanzo"这个值时，它会作为第一次yield方法的返回值进入NinjaGenerator函数中，并赋值给imposter，所以上一次yield可以接收到next()方法中的参数作为返回值供后面的yield使用，这样就可以与generator进行双向数据交流，但是第一次是无法通过next传递参数的，只能通过构造时传入。

**此外，通过抛出异常的方式也能向generator里传入一些值**

```js
function* NinjaGenerator() {
  try {
    yield "Hattori"
    fail("The expected exception didn't occur")
  } catch(e) {
    // receive e
  }
}

const ninjaIterator = NinjaGenerator()
const result1 = ninjaIterator.next()
ninjaIterator.throw("some information")
```

#### 4.3 探索生成器内部的构成

生成器的运行流程：

- 挂起开始—— 创建了一个生成器后，它最先以这种状态开始。其中的任何代码都未执行。
- 执行—— 生成器中的代码已执行。执行要么是刚开始，要么是从上次挂起的时候继续的。当生成器对应的迭代器调用了next方法，并且当前存在可执行的代码时，生成器都会转移到这个状态。
- 挂起让渡—— 当生成器在执行过程中遇到了一个yield表达式，它会创建一个包含着返回值的新对象，随后再挂起执行。生成器在这个状态暂停并等待继续执行。
- 完成—— 再生成器执行期间，如果代码执行到return语句或者全部代码执行完毕，生成器就进入该状态。

**generator以及iterator运行时的context**

- `const ninjaIterator = NinjaGenerator()`，当一个函数被调用，正常函数都会执行完毕并将context销毁，生成器比较特殊，他不会执行任何代码，他会生成一个新的迭代器并从中返回。由于类似于闭包的存在，iterator能够获取到generator中的变量，NinjaGenerator()函数执行完毕的context并不会被销毁。
- `const result1 = ninjaIterator.next()` ，如果是一个普通函数调用，这个语句会创建一个新的next()环境context，并压入栈中，但是next()会重新激活对应的context，在这里，是NinjaGenerator，并把该上下文压入栈中，从上次离开的地方继续执行。
- `yield "Hattori"` ，生成器函数运行时遇到yield关键字，表示需要挂起生成器的执行并返回该值。
- 当遇到return或者代码全部执行完毕生成器就会进入结束状态。

### 5 Promise

使用Promise异步获取数据

```js
function getJSON(url) {
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest()
    
    request.open("GET", url)
    
    request.onload = function() {
      try {
        if (this.status === 200) {
          resolve(JSON.parse(this.response))
        } else {
          reject(this.status + " " + this.statusText)
        }
      } catch (e) {
        reject(e.message)
      }
    }
    
    request.onerror = function() {
      reject(this.status + " " + this.statusText)
    }
    
    request.send()
    
  })
}

getJSON("data/ninjas.json").then(ninjas => {
  // obtain datas
}).catch(e => fail("Shouldn't be here:" + e))

```

#### 5.1 Promise 与 generator的结合

ES7中新增加了async和await关键字，在这之前，我们可以通过Promise和generator达到同样的效果。

```js
async(function*() {
  try {
    const ninjas = yield getJSON("data/ninjas.json")
    const missions = yield getJSON("ninjas[0].missionUrl")
    const missionDescription = yield getJSON(missions[0].detailsUrl)
    // we can study the mission detail here
    } catch (e) {
      // handle some error
    }
})

function async(generator) {
  var iterator = generator()
  
  function handle(iteratorResult) {
    if (iteratorResult.done) { return }
    
    const iteratorValue = iteratorResult.value
    
    if (iteratorValue instanceof Promise) {
      iteratorValue.then(res => handle(iterator.next(res)))
      						 .catch(err => iterator.throw(err))
    }
  }
  
  try {
    handle(iterator.next())
  } catch (e) {
    iterator.throw(e)
  }
}
```

async函数接收一个generator作为参数，初始化了一个generator，它利用了generator遇到yield会将函数挂起等待下次调用的特性，每次调用next()函数都会返回一个Promise对象，在Promise接收到了resolve后，得到数据作为参数传给next(),在generator内部，定义的变量就接收到了从服务器返回的值，并遇到下一个yield并挂起，直到执行完成。如果Promise接受到的是reject或者隐式错误，会抛出一个err，这时同样会被generator中相应位置捕获。

在es7中，我们可以使用以下代码来实现，两者的实现思路是相同的。

```js
(async function() {
  try {
    const ninjas = await getJSON("data/ninjas.json")
    const missions = await getJSON("ninjas[0].missionUrl")
    // do something here
  } catch(e) {
		// handle some error
  }
})()
```

