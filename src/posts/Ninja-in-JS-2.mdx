---
title: Secrets of the JavaScript Ninja学习笔记(2)
date: 2017-10-13 15:42:59
tags: JavaScript, Object
---
> 记录书中重要的，有趣的，自己掌握的不太好的。
>

### 1 面向对象和原型

原型的概念很简单。每个对象都有含有原型的引用，当查找属性时，若对象本身不具有该属性，则会查找原型上是否具有该属性。

#### 1.1 对象构造器和原型

```js
function Ninja() {
  this. swung = false
  this.swingSword = function() {
    return !this.swung
  }
  Ninja.prototype.swingSword = function() {
    return this.swung
  }
}

const ninja = new Ninja()
ninja.swingSword()
//true
```

在构造函数内部，this指向新创建的对象，所以在构造器内添加的属性直接在新的ninja实例上。然后，当通过ninja访问SwingSwung属性时，就不需要遍历原型链，就立即可以找到并返回了在构造器内创建的属性。

```js
function Ninja() {
  this.swung = true
}
const ninja1 = new Ninja()
Ninja.prototype.swingSword = function(){
  return this.swung
}
ninja1.swingSword()
// true

Ninja.prototype = {
  pierce: function() {
    return true
  }
}
// 尽管我们已经完全替换了Ninja的构造原型，但是实例化后的Ninja对象仍然具有swingSwung方法
// 因为对象ninja1任然保持着对旧的Ninja原型的引用
ninja1.swingSword()
// true

// 新创建的ninja2实例拥有新原型的引用，因此不具有swingSwung方法，仅具有pierce方法
const ninja2 = new Ninja()
ninja2.pierce()
// true
ninja1.swingSword()
// undefined
```

每个函数的都有一个原型对象，它的原型对象都一个constructor属性，指向函数本身。

```js
function Ninja() {}

const ninja = new Ninja()
const ninja2 = ninja.constructor()

ninja2 instanceof Ninja
// true
```

#### 1.2 实现继承

```js
function Person(){}
Person.prototype.dance = function(){}

function Ninja(){}
Ninja.prototype = new Person()

const ninja = new Ninja()
ninja instanceof Ninja //true
ninja instanceof Person //true
ninja instanceof Object //true
ninja.constructor // [Function: Person]
```

##### 1.2.1 重写constructor属性的问题

像上面所看到的，我们期望ninja的constructor指向的是Ninja，但是由于直接设置了Ninja的prototype为Person，而Person原型的constructor指向的是Person()，这显然不是我们所期望的。所以我们需要修复这个问题。

**在JavaScript中，对象是通过属性描述进行描述的，我们可以配置以下关键字：**

- configurable —— 如果设置为true，则可以修改删除属性，如果false，则不行。
- enumerable —— 如果设置为true，则可以在for-in循环对象属性时出现。
- value —— 指定属性的值，默认为undefined。
- writable —— 如果设置为true，则可通过赋值语句修改属性值。
- get —— 定义getter函数，当访问属性时调用，不能与value和writable同时使用。
- set —— 定义setter函数，当对属性赋值时发生调用，也不能与value和writable同时使用。

如果想要调整属性的配置信息，我们可以使用内置的Object.defineProperty方法：

```js
var ninja = {}
ninja.name = "Yoshi"
ninja.weapon = "kusarigama"
// 一个不可修改或删除且不可遍历的属性。
Object.defineProperty(ninja, "sneaky", {
  configurable: false,
  enumerable: false,
  value: true,
  writable: true
})

```

此时，我们就可以解决之前提到的问题了：

```js
function Person(){}
Person.prototype.dance = function(){}

function Ninja(){}
Ninja.prototype = new Person()

Object.defineProperty(Ninja.prototype, "constructor", {
  enumerable: false,
  value: true,
  writable: true
})

const ninja = new Ninja()
ninja.constructor // [Function: Ninja]
```

#### 1.3 JavaScript中的class

class是语法糖，但是底层仍然是基于原型的实现。

```js
class Person {
  constructor(name) {
    this.name = name
  }
  
  dance() {
    return true
  }
}

// 实现继承
class Ninja extends Person{
  // 构造函数
  constructor(name, level) {
    super(name)
    this.level = level
  }
  
  swingSword() {
    return true
  }
  // 静态方法，只能在Ninja对象获取，在实例上无法访问
  static compare(ninja1, ninja2) {
    return ninja1.level - ninja2.level
  }
}
```

function().prototype --> Object  Object.constructor --> function

### 2 控制对象的访问

#### 2.1 getter和setter

```js
class NinjaCollection {
  constructor() {
    this.ninjas = ["Yoshi", "Kuma", "Hattori"]
  }
  get firstNinja() {
    return this.ninjas[0]
  }
  set firstNinja(value) {
    this.ninjas[0] = value
  }
}
```

> **注意：** 针对指定属性不一定需要同时定义getter和setter。例如，我们通常仅提供getter。如果在某些情况下需要写入属性值，具体的行为取决于代码是在严格模式下还是非严格模式。非严格模式下，对仅有getter的属性赋值不起作用，JavaScript引擎默默地忽略我们的请求，严格模式下会抛出异常。

```js
// 给私有变量定义方法，使其能够被外部访问
function Ninja() {
  let _skillLevel = 0
  
  Object.defineProperty(this, 'skillLevel', {
    get: () => {
      return _skillLevel
    },
    set value => {
    // 可以设置校验属性值
    if(!Number.isInteger(value)){
    	throw new TypeError("Skill level should be a number")
  	}
    	_skillLevel = value
  	}
  })
}

const ninja = new Ninja()
ninja.skillLevel
// 0
ninja.skillLevel = 10
// 10
ninja.skillLevel = 'Yoshi'
// error: TypeError
```

**定义计算属性**

```js
const shogun = {
  name: "Yoshiaki",
  clan: "Ashikaga",
  get fullTitle() {
    return this.name + " " + this.clan
  }
  set fullTitle(value) {
  	const segments = value.split(" ")
  	this.name = segments[0]
  	this.clan = segments[1]
	}
}

shogun.fullTitle
// Yoshiaki Ashikaga

shogun.fullTitle = "Ieyasu Tokugawa"

```

#### 2.2 Proxy()

代理(Proxy)使我们通过代理控制对另一个对象的访问。通过代理可以定义当对象发生交互时可执行的自定义行为——如读取或设置属性值，或调用方法。可以将代理理解为通用化的setter与getter，区别是每个setter与getter仅能控制单个对象属性，而代理可用于对象交互的通用处理，包括调用对象的方法。

过去使用setter与getter处理日志记录、校验数据、计算属性等操作，均可使用代理对他们进行处理。代理更加强大。使用代理我们可以很容易地在代码中添加分析和性能度量，自动填充对象属性以避免讨厌的null异常，包装宿主对象，例如DOM用于减少跨浏览器的不兼容性。

```js
// 原对象
const emperor = { name: "Komei" }
// 代理对象，提供了get和set方法
const representative = new Proxy(emperor, {
  get: (target, key) => {
    return key in target ? target[key] : "Don't bother the emperor"
  },
  set: (target, key, value) => {
    target[key] = value
  }
})

emperor.name	// Komei
representative.name	// Komei
emperor.nickname	// undefined
representative.nickname	// Don't bother the emperor

// 通过代理对象添加属性后，代理对象和原对象都可以访问nickname属性
representative.nickname = "Tenno"
emperor.nickname	// Tenno
representative.nickname	// Tenno
```

除了get和set之外，还有许多其他的内置方法：

- 调用函数时激活apply，使用new操作符时激活construct
- 读取/写入属性时激活get与set
- 执行for-in语句时激活enumerate
- 获取和设置属性值时激活getPrototypeOf与setPropertyOf.

##### 2.2.1 使用代理评估性能

```js
// 判断一个数是否是质数
function isPrime(number){
  if(number < 2) {return false}
  for(let i = 2; i < number; i++) {
    if(number % i === 0) { return false}
  }
  return true
}

// 使用代理当函数调用时计算性能
isPrime = new Proxy(isPrime, {
  apply: (target, thisArg, args) => {
    console.time("isPrime")
    const result = target.apply(thisArg, args)
    console.timeEnd("isPrime")
    return result
  }
})

isPrime(1299827)
// isPrime: 7.363ms
```

**最后，目前代理的效率还不是很高，在需要执行多次的代码中需要谨慎使用。**

### 3 代码模块化

#### 3.1 ES6之前的模块化代码

在ES6之前，开发者们为了编写模块化代码，不得不创造性地使用JavaScript现有的语法特性。当决定用哪个功能时，我们需要谨记，每个模块系统至少应该能执行以下操作：

- 定义模块接口，通过接口可以调用模块的功能。
- 隐藏模块的内部实现，使模块的使用者无需关注内部实现细节。同时，隐藏模块的内部实现，避免可能产生的副作用和对bug的不必要修改。

##### 3.1.1 使用对象、闭包和立即执行函数实现模块

- 隐藏模块内部实现——我们已经知道，调用JavaScript函数创建新的作用域，我们可以在该作用域中定义变量，此时定义的变量只在当前函数中可见。因此，我们隐藏模块内部实现的一个选择是使用函数作为模块。采用这种方式，所有函数变量都成为模块内部变量，模块外部不可见。
- 定义模块接口——使用函数实现模块意味着只能在模块内部访问变量。但是，如果使用其他代码调试该模块，我们必须定义简洁的接口，可以通过接口暴露模块提供的功能。一种实现方式是利用对象和闭包。思路是，通过函数模块返回代表模块公共接口的对象。该对象必须包含模块提供的方法，而这些方法将通过闭包保持模块内部变量，甚至在模块函数执行完成之后仍然保持模块变量。

```js
// 通过立即执行函数，我们可以隐藏指定的模块执行细节，通过添加对象和闭包
// 我们可以定义模块接口，通过接口暴露模块功能
const MouseCounterModule = function() {
  let numClicks = 0
  const handleClick = () => {
		alert(++numClicks)
  }
  
  return {
    countClicks: () => {
      document.addEventListener("click", handleClick)
    }
  }
}()

// 我们在模块中增加附加特性，但是我们不能修改原来的代码。
(function(module){
  let numScrolls = 0
  const handleScroll = () => {
		alert(++numScrolls)
  }
  
  module.countScrolls = () => {
    document.addEventListener("wheel", handleScroll)
  }
})(MouseCounterModule)
```

这种在JavaScript中通过立即执行函数、对象和闭包来创建模块的方式成为模块化模式。这是由Douglas Crockford推广，也是第一个大规模流行的JavaScript代码模块化的方法。

我们发现，通过立即执行函数扩展模块，无法共享模块私有变量，因为每个函数都分别创建了新的作用域。countScroll是在完全独立的作用域中创建的，具有完全私有的变量：numScroll和handleScroll。扩展的模块无法共享原有模块的内部属性。并且，我们开始创建模块化应用时，模块本身常常依赖其他模块的功能，然而，模块模式无法实现这些依赖关系。

##### 3.1.2 AMD 与 CommonJS

为了解决上面提到的问题，出现了两个相互竞争的标准，AMD(Asynchronous Module Definition)和CommonJS。

**AMD**

AMD设计理念是明确基于浏览器，目前它最流行的实现是RequireJS。

```js
// 一个依赖于jQuery的小模块
define('MouseCounterModule', ['jQuery'], $ => {
  let numClicks = 0
  const handleClick = () => {
    alert(++numClicks)
  }
  
  return {
    countClicks: () => {
			$(document).on("click", handleClick)
    }
  }
})
```

AMD提供名为define的函数，它接收一下参数。

- 新创建模块的ID，使用该ID，可以在系统的其他部分引用该模块。
- 当前模块依赖的模块ID列表。
- 初始化模块的工厂函数，该工厂函数接收依赖的模块列表作为参数。

它有以下几项有点：

- 自动处理依赖，我们无需考虑模块引入的顺序。
- 异步加载模块，避免阻塞。
- 在同一个文件中可以定义多个模块。

**CommonJS**

CommonJS的设计是面向通用JavaScript环境。在Node.js社区拥有最多的用户。CommonJs要求一个文件是一个模块，文件中的代码就是模块中的一部分。

```js
// 一个依赖于jQuery的小模块
const $ = require("jQuery")
let numClicks = 0
const handleClick = () => {
  alert(++numClicks)
}

module.exports = {
	countClick: () => {
		$(document).on("click", handleClick)
  }
}
```

#### 3.2 ES6模块

ES6的模块相关很简单，也很熟悉。目前可用的语法：

| 代      码                                                   | 含      义                   |
| :----------------------------------------------------------- | :--------------------------- |
| export const ninja = "Yoshi"                                 | 导出变量                     |
| export function compare(){}                                  | 导出函数                     |
| export class Ninja{}                                         | 导出类                       |
| export default class Ninja{}                                 | 导出默认类                   |
| export default function Ninja()                              | 导出默认函数                 |
| const ninja = "Yoshi"<br />function compare()<br />export { ninja, compare } | 导出存在的变量               |
| export { ninja as samurai, compare }                         | 使用别名导出                 |
| import { ninja, Ninja } from "Ninja.js"                      | 导入命名导出                 |
| import Ninja from "Ninja.js"                                 | 导入默认导出                 |
| import * as Ninja from "Ninja.js"                            | 导入模块中声明的全部导出内容 |
| import { ninja as Ninja } from "Ninja.js"                    | 通过别名导入模块中命名的内容 |

